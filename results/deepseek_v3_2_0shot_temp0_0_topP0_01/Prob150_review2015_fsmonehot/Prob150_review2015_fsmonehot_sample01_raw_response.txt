We can derive the next-state logic and output logic directly from the state transition table and one-hot encoding.  

Let¡¯s label the states in order:  

S      = state[0]  
S1     = state[1]  
S11    = state[2]  
S110   = state[3]  
B0     = state[4]  
B1     = state[5]  
B2     = state[6]  
B3     = state[7]  
Count  = state[8]  
Wait   = state[9]  

---

**Next-state logic by inspection:**

- **S_next** =  
  (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack)  

- **S1_next** =  
  (S & d) | (S1 & d & ~state[2])  // Actually from table: S1->S if d=0, S1->S11 if d=1, so S1_next only from S with d=1? Wait, check:  
  Let's carefully trace:  
  From S: if d=1 ¡ú S1.  
  From S1: if d=0 ¡ú S, if d=1 ¡ú S11. So S1_next only from S with d=1. Yes.  
  So S1_next = S & d.

- **S11_next** =  
  (S1 & d) | (S11 & d)  

- **S110_next** =  
  (S11 & ~d)  

- **B0_next** =  
  (S110 & d)  

- **B1_next** =  
  B0  

- **B2_next** =  
  B1  

- **B3_next** =  
  B2  

- **Count_next** =  
  B3 | (Count & ~done_counting)  

- **Wait_next** =  
  (Count & done_counting) | (Wait & ~ack)  

---

**Output logic:**

- shift_ena = B0 | B1 | B2 | B3  
- counting = Count  
- done = Wait  

---

Now implement only the combinational part for the requested signals:  

```verilog
  assign S_next = (state[0] & ~d) | (state[1] & ~d) | (state[3] & ~d) | (state[9] & ack);
  
  assign S1_next = state[0] & d;
  
  assign B3_next = state[6]; // B2 -> B3
  
  assign Count_next = state[7] | (state[8] & ~done_counting);
  
  assign Wait_next = (state[8] & done_counting) | (state[9] & ~ack);
  
  assign shift_ena = state[4] | state[5] | state[6] | state[7];
  
  assign counting = state[8];
  
  assign done = state[9];
```