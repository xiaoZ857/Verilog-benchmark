We need to track the state with four possible high-level modes: walking left, walking right, falling, and digging.  
Since it’s a Moore machine, outputs depend only on the current state.  

Let’s define states:  
- WL: walking left  
- WR: walking right  
- FALL_L: falling, but will resume walking left when ground=1  
- FALL_R: falling, but will resume walking right when ground=1  
- DIG_L: digging, but will resume walking left when ground=0 (then fall)  
- DIG_R: digging, but will resume walking right when ground=0 (then fall)  

Transitions:  
1. Reset → WL.  
2. In WL or WR:  
   - If ground=0 → go to FALL_L or FALL_R accordingly.  
   - Else if dig=1 → go to DIG_L or DIG_R accordingly.  
   - Else if bumped on left (for WR) or bumped on right (for WL) → switch walking direction.  
   - Else stay in WL/WR.  
3. In FALL_L or FALL_R:  
   - If ground=1 → go to WL or WR accordingly.  
   - Else stay falling.  
4. In DIG_L or DIG_R:  
   - If ground=0 → go to FALL_L or FALL_R accordingly.  
   - Else stay digging.  

Priority in WL/WR: fall > dig > bump.  

Outputs:  
- walk_left = 1 if state is WL or FALL_L or DIG_L.  
- walk_right = 1 if state is WR or FALL_R or DIG_R.  
- aaah = 1 if state is FALL_L or FALL_R.  
- digging = 1 if state is DIG_L or DIG_R.  

Here’s the Verilog implementation:  

```verilog
    parameter WL = 3'd0, WR = 3'd1, FALL_L = 3'd2, FALL_R = 3'd3, DIG_L = 3'd4, DIG_R = 3'd5;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            WL: begin
                if (~ground) next_state = FALL_L;
                else if (dig) next_state = DIG_L;
                else if (bump_left) next_state = WR;
                else next_state = WL;
            end
            WR: begin
                if (~ground) next_state = FALL_R;
                else if (dig) next_state = DIG_R;
                else if (bump_right) next_state = WL;
                else next_state = WR;
            end
            FALL_L: begin
                if (ground) next_state = WL;
                else next_state = FALL_L;
            end
            FALL_R: begin
                if (ground) next_state = WR;
                else next_state = FALL_R;
            end
            DIG_L: begin
                if (~ground) next_state = FALL_L;
                else next_state = DIG_L;
            end
            DIG_R: begin
                if (~ground) next_state = FALL_R;
                else next_state = DIG_R;
            end
            default: next_state = WL;
        endcase
    end

    always @(posedge clk, posedge areset) begin
        if (areset) state <= WL;
        else state <= next_state;
    end

    assign walk_left = (state == WL) | (state == FALL_L) | (state == DIG_L);
    assign walk_right = (state == WR) | (state == FALL_R) | (state == DIG_R);
    assign aaah = (state == FALL_L) | (state == FALL_R);
    assign digging = (state == DIG_L) | (state == DIG_R);
endmodule
```