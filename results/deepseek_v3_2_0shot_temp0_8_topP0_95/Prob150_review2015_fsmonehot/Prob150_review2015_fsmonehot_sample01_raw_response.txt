We can derive the next-state and output logic directly from the state transition table and one-hot encoding.  

**Next-state logic:**  

From the table:  

- **S_next**:  
  Next state is S when:  
  (current state is S and d=0) OR  
  (current state is S1 and d=0) OR  
  (current state is S110 and d=0) OR  
  (current state is Wait and ack=1)  

  So:  
  S_next = (state[0] & ~d) | (state[1] & ~d) | (state[3] & ~d) | (state[9] & ack);  

- **S1_next**:  
  Next state is S1 when:  
  (current state is S and d=1)  

  So:  
  S1_next = state[0] & d;  

- **B3_next**:  
  Next state is B3 when current state is B2 (since B2 always goes to B3).  

  So:  
  B3_next = state[6];  // B2 is index 6 if encoding order is S(0), S1(1), S11(2), S110(3), B0(4), B1(5), B2(6), B3(7), Count(8), Wait(9)  

- **Count_next**:  
  Next state is Count when current state is B3.  

  So:  
  Count_next = state[7];  

- **Wait_next**:  
  Next state is Wait when:  
  (current state is Count and done_counting=1)  

  So:  
  Wait_next = state[8] & done_counting;  

**Output logic:**  

From the table:  

- shift_ena = 1 when current state is B0, B1, B2, or B3.  
  So: shift_ena = state[4] | state[5] | state[6] | state[7];  

- counting = 1 when current state is Count.  
  So: counting = state[8];  

- done = 1 when current state is Wait.  
  So: done = state[9];  

Here¡¯s the Verilog implementation:  

```verilog
  assign S_next = (state[0] & ~d) | (state[1] & ~d) | (state[3] & ~d) | (state[9] & ack);
  assign S1_next = state[0] & d;
  assign B3_next = state[6];
  assign Count_next = state[7];
  assign Wait_next = state[8] & done_counting;
  
  assign shift_ena = state[4] | state[5] | state[6] | state[7];
  assign counting = state[8];
  assign done = state[9];
endmodule
```