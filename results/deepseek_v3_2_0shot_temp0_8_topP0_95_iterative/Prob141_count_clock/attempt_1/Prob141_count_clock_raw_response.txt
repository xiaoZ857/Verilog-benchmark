We need to implement a 12-hour clock with BCD digits for hh, mm, ss, and a pm indicator.  
The clock increments only when `ena` is high, and resets synchronously when `reset` is high.  
Reset sets time to 12:00 AM.  

Let's break it down:  

- **Seconds (ss)**: Two BCD digits, range 00–59.  
  - Lower digit (ss[3:0]) counts 0–9, then resets to 0 and increments upper digit.  
  - Upper digit (ss[7:4]) counts 0–5, resets to 0 when reaching 6 (i.e., 59 → 00).  
  - When seconds go from 59 to 00, increment minutes.  

- **Minutes (mm)**: Two BCD digits, range 00–59, same logic as seconds.  
  - When minutes go from 59 to 00, increment hours.  

- **Hours (hh)**: Two BCD digits, range 01–12, with AM/PM toggle at 12→01 transition.  
  - BCD digits:  
    - Lower hour digit (hh[3:0]) counts 0–9, but special at 12→01.  
    - Upper hour digit (hh[7:4]) is 0 or 1.  
  - Sequence: 01, 02, ..., 09, 10, 11, 12, then back to 01, and toggle AM/PM at 12→01.  
  - Reset sets hh = 8'h12 (BCD 12), mm = 8'h00, ss = 8'h00, pm = 0.  

We'll code each stage with BCD carry logic.

```verilog
  // Seconds counter
  always @(posedge clk) begin
    if (reset) begin
      ss <= 8'h00;
    end else if (ena) begin
      if (ss[3:0] == 4'd9) begin
        ss[3:0] <= 4'd0;
        if (ss[7:4] == 4'd5) begin
          ss[7:4] <= 4'd0;
        end else begin
          ss[7:4] <= ss[7:4] + 1;
        end
      end else begin
        ss[3:0] <= ss[3:0] + 1;
      end
    end
  end

  // Minutes counter (increments when seconds carry)
  wire min_inc = ena && (ss == 8'h59);
  always @(posedge clk) begin
    if (reset) begin
      mm <= 8'h00;
    end else if (min_inc) begin
      if (mm[3:0] == 4'd9) begin
        mm[3:0] <= 4'd0;
        if (mm[7:4] == 4'd5) begin
          mm[7:4] <= 4'd0;
        end else begin
          mm[7:4] <= mm[7:4] + 1;
        end
      end else begin
        mm[3:0] <= mm[3:0] + 1;
      end
    end
  end

  // Hours counter (increments when minutes carry)
  wire hour_inc = min_inc && (mm == 8'h59);
  always @(posedge clk) begin
    if (reset) begin
      hh <= 8'h12; // BCD 12
      pm <= 1'b0;
    end else if (hour_inc) begin
      // Handle hour increment with BCD
      if (hh == 8'h12) begin
        hh <= 8'h01;
      end else if (hh[3:0] == 4'd9) begin
        // e.g., 09 -> 10
        hh[3:0] <= 4'd0;
        hh[7:4] <= hh[7:4] + 1;
      end else begin
        hh[3:0] <= hh[3:0] + 1;
      end
      // Toggle PM at 12:59:59 -> 01:00:00
      if (hh == 8'h11 && mm == 8'h59 && ss == 8'h59) begin
        // Actually, the toggle happens when transitioning from 12 to 01
        // But here we are at hh == 11, so next is 12, no toggle yet.
        // Wait, careful: