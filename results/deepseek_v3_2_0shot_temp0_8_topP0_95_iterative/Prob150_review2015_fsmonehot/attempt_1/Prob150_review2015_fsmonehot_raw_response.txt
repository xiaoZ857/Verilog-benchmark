We'll derive the next-state logic for each state based on the given transitions, using the one-hot encoding. The current state is given as a 10-bit vector `state[9:0]` where:

- `state[0]` = S  
- `state[1]` = S1  
- `state[2]` = S11  
- `state[3]` = S110  
- `state[4]` = B0  
- `state[5]` = B1  
- `state[6]` = B2  
- `state[7]` = B3  
- `state[8]` = Count  
- `state[9]` = Wait  

---

**Next-state logic equations by inspection:**

1. **S_next**:  
   From: S (if d=0), S1 (if d=0), S110 (if d=0), Wait (if ack=1).  
   So:  
   `S_next = (state[0] & ~d) | (state[1] & ~d) | (state[3] & ~d) | (state[9] & ack);`

2. **S1_next**:  
   From: S (if d=1).  
   So:  
   `S1_next = state[0] & d;`

3. **B3_next**:  
   From: B2 (always).  
   So:  
   `B3_next = state[6];`

4. **Count_next**:  
   From: B3 (always).  
   So:  
   `Count_next = state[7];`

5. **Wait_next**:  
   From: Count (if done_counting=1).  
   So:  
   `Wait_next = state[8] & done_counting;`

---

**Output logic equations:**

- `shift_ena = state[4] | state[5] | state[6] | state[7];`  
  (B0, B1, B2, B3)

- `counting = state[8];`  
  (Count state)

- `done = state[9];`  
  (Wait state)

---

**Verilog implementation:**

```verilog
assign S_next = (state[0] & ~d) | (state[1] & ~d) | (state[3] & ~d) | (state[9] & ack);
assign S1_next = state[0] & d;
assign B3_next = state[6];
assign Count_next = state[7];
assign Wait_next = state[8] & done_counting;

assign shift_ena = state[4] | state[5] | state[6] | state[7];
assign counting = state[8];
assign done = state[9];
endmodule
```