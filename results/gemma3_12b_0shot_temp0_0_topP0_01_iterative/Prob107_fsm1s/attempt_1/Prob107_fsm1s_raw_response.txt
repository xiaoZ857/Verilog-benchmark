```verilog
module TopModule (
  input clk,
  input in,
  input reset,
  output out
);

  // Define the states
  parameter B_STATE = 2'b00;
  parameter A_STATE = 2'b01;

  // Declare the state register
  reg current_state;

  // Define the next-state logic
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      current_state <= B_STATE;
    end else begin
      case (current_state)
        B_STATE: begin
          if (in == 0) begin
            current_state <= A_STATE;
          end else begin
            current_state <= B_STATE;
          end
        end
        A_STATE: begin
          if (in == 0) begin
            current_state <= B_STATE;
          end else begin
            current_state <= A_STATE;
          end
        end
        default: begin
          current_state <= B_STATE; // Default to B_STATE in case of unexpected state
        end
      endcase
    end
  end

  // Define the output logic
  always @(current_state) begin
    case (current_state)
      B_STATE: out = 1;
      A_STATE: out = 0;
      default: out = 1; // Default to 1 in case of unexpected state
    endcase
  end

endmodule
```

**Explanation:**

1. **Module Declaration:**
   - `module TopModule (clk, in, reset, out);` declares the module with the specified input and output signals.

2. **State Definition:**
   - `parameter B_STATE = 2'b00;` and `parameter A_STATE = 2'b01;` define the two states of the state machine.  Using parameters makes the code more readable and maintainable.

3. **State Register:**
   - `reg current_state;` declares a register to hold the current state of the state machine.  Registers hold their values until explicitly changed.

4. **Next-State Logic (Synchronous Reset):**
   - `always @(posedge clk or posedge reset)`: This `always` block is triggered on the positive edge of the clock signal (`posedge clk`) or the positive edge of the reset signal (`posedge reset`).  This makes the state machine synchronous.
   - `if (reset) begin ... end`:  This `if` statement handles the reset condition. When `reset` is high, the state machine is initialized to the `B_STATE`.
   - `case (current_state) ... endcase`: This `case` statement defines the next-state logic based on the current state and the input `in`.  It implements the state transitions described in the problem statement.
   - `default: current_state <= B_STATE;`:  This `default` case is important for robustness.  If the state machine somehow enters an undefined state, it will transition back to the `B_STATE`.

5. **Output Logic:**
   - `always @(current_state)`: This `always` block is triggered whenever the `current_state` changes.
   - `case (current_state) ... endcase`: This `case` statement defines the output `out` based on the current state.  It implements the output assignments described in the problem statement.
   - `default: out = 1;`:  Similar to the next-state logic, this `default` case ensures that the output is defined even if the state machine enters an unexpected state.

**How it works:**

The code implements a Moore state machine.  In a Moore machine, the output is a function of the *current state* only.  The `always @(current_state)` block ensures that the output changes only when the state changes.

The `reset` signal forces the state machine to the `B_STATE` on the positive edge of the clock.  After reset, the state machine transitions between states `A` and `B` based on the value of the input `in`.  The output `out` is determined by the current state.

**To use this module:**

1.  **Save:** Save the code as a `.v` file (e.g., `top_module.v`).
2.  **Instantiate:** Instantiate the module in your top-level design.
3.  **Connect Signals:** Connect the `clk`, `in`, `reset`, and `out` signals to the appropriate signals in your design.
4.