```verilog
module TopModule (
  input clk,
  input reset,
  output reg [3:0] q
);

  always @(posedge clk) begin
    if (reset) begin
      q <= 0;
    end else begin
      q <= q + 1;
    end
  end

endmodule
```

**Explanation:**

* **`module TopModule ( ... );`**: Defines the module named `TopModule` with the specified input and output ports.
* **`input clk, reset;`**: Declares `clk` (clock) and `reset` as input signals.
* **`output reg [3:0] q;`**: Declares `q` as a 4-bit register (output) that will hold the counter value.  `reg` is required because `q` is assigned a value within an `always` block.
* **`always @(posedge clk) begin ... end`**: This is a sequential block that executes on the positive edge of the clock signal (`clk`).
* **`if (reset) begin q <= 0; end`**:  This is the synchronous reset condition. When `reset` is high (active high), the counter is reset to 0. The non-blocking assignment (`<=`) ensures that the update happens at the end of the clock cycle.
* **`else begin q <= q + 1; end`**:  If the `reset` signal is low, the counter increments by 1 on each positive clock edge.  Again, the non-blocking assignment is used.

**How it Works:**

1. **Initialization:** When the circuit is powered on or reset is asserted, `q` is initialized to 0.
2. **Counting:** On each positive clock edge, the code checks if `reset` is high.
   * If `reset` is high, `q` is set to 0.
   * If `reset` is low, `q` is incremented by 1.
3. **Wrap-around:** When `q` reaches 15 (1111 in binary), the next increment will cause it to wrap around to 0 (0000 in binary) because `q` is a 4-bit register. This ensures the counter counts from 0 to 15 inclusive.

**To simulate this code:**

You would typically use a Verilog simulator (like ModelSim, Icarus Verilog, or Vivado simulator) and write a testbench to apply clock and reset signals and observe the output `q`.  A simple testbench might look like this:

```verilog
module TopModule_tb;

  reg clk;
  reg reset;
  wire [3:0] q;

  TopModule uut (
    .clk(clk),
    .reset(reset),
    .q(q)
  );

  initial begin
    clk = 0;
    reset = 1; // Assert reset initially

    #10 reset = 0; // Deassert reset after 10 time units

    #100 $finish; // Finish simulation after 100 time units
  end

  always #5 clk = ~clk; // Toggle clock every 5 time units

  initial begin
    $monitor("Time=%d, clk=%b, reset=%b, q=%b", $time, clk, reset, q);
  end

endmodule
```

This testbench applies a clock signal and deasserts the reset after a short time.  The `$monitor` statement prints the values of the signals at each time step, allowing you to observe the counter's operation.