```verilog
module TopModule (
  input clk,
  input in,
  input reset,
  output out
);

  parameter A = 1'b0;
  parameter B = 1'b1;

  reg current_state;
  reg next_state;

  always @(posedge clk) begin
    if (reset) begin
      current_state <= B;
    end else begin
      current_state <= next_state;
    end
  end

  always @(*) begin
    case (current_state)
      A: begin
        if (in == 0) begin
          next_state = B;
        end else begin
          next_state = A;
        end
      end
      B: begin
        if (in == 0) begin
          next_state = A;
        end else begin
          next_state = B;
        end
      end
      default: begin
        next_state = B; // Default to B in case of undefined state
      end
    endcase
  end

  assign out = current_state == B ? 1 : 0;

endmodule
```

**Explanation:**

1. **Module Declaration:**
   - `module TopModule (clk, in, reset, out);` declares the module with the specified input and output signals.

2. **Parameter Definition:**
   - `parameter A = 1'b0;` and `parameter B = 1'b1;` define symbolic constants for the states A and B.  This makes the code more readable and maintainable.

3. **State Register:**
   - `reg current_state;` and `reg next_state;` declare registers to hold the current and next states of the state machine.

4. **Synchronous Reset:**
   - `always @(posedge clk) begin ... end` This block is triggered on the positive edge of the clock signal.
   - `if (reset) begin current_state <= B; end`  If the `reset` signal is high, the state machine is reset to state B.
   - `else begin current_state <= next_state; end` Otherwise, the `current_state` is updated with the value of `next_state`.

5. **Next State Logic:**
   - `always @(*) begin ... end` This block describes the logic for determining the next state based on the current state and input `in`. The `*` means that the block is sensitive to any change in its inputs (current_state and in).
   - `case (current_state)`:  A `case` statement is used to determine the next state based on the current state.
   - Inside each state (A and B), `if (in == 0)` and `else` statements define the next state based on the value of the input `in`.
   - `default: begin next_state = B; end` This is a good practice to provide a default state assignment in case the `current_state` somehow becomes an undefined value.  It ensures the FSM will at least go to a known state.

6. **Output Logic:**
   - `assign out = current_state == B ? 1 : 0;` assigns the output `out` based on the value of `current_state`.  If `current_state` is B, `out` is 1; otherwise, `out` is 0.  This implements the described output behavior.

**How it works:**

The Verilog code implements a Moore state machine. In a Moore machine, the output is a function of the current state only.  The code follows the state transitions described in the problem statement:

- **From State B:**
    - If `in` is 0, the state machine transitions to state A.
    - If `in` is 1, the state machine remains in state B.
- **From State A:**
    - If `in` is 0, the state machine transitions to state B.
    - If `in` is 1, the state machine remains in state A.

The `reset` signal brings the state machine back to the initial state `B` on the positive edge of the clock. The `out` signal is high (1) when the state machine is in state `B`, and low (0) when it's in state `A`.
