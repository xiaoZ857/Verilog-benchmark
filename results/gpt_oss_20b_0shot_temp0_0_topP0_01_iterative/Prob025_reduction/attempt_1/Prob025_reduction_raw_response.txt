Below is a minimal, synthesizable Verilog implementation of the requested **even‑parity generator**.  
The module is purely combinational – the parity bit is produced immediately from the 8‑bit input, so no clock is required.

```verilog
// ---------------------------------------------------------------------------
//  TopModule
//  ---------
//  Computes an even‑parity bit for an 8‑bit input word.
//  The parity bit is the XOR of all eight data bits.
//
//  Inputs:
//      in   : 8‑bit data word
//
//  Outputs:
//      parity : 1‑bit even‑parity (XOR of all bits of 'in')
// ---------------------------------------------------------------------------

module TopModule (
    input  wire [7:0] in,      // 8‑bit data input
    output wire       parity   // 1‑bit parity output
);

    // Combinational parity calculation
    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^
                    in[4] ^ in[5] ^ in[6] ^ in[7];

endmodule
```

### Notes

* **Combinational logic** – The `assign` statement drives `parity` continuously from the XOR of the eight input bits.  
* **Even parity** – The XOR of all bits yields `0` when the number of `1`s is even, and `1` when it is odd, which is the definition of even parity.  
* **No clock** – Since the operation is purely combinational, no clock edge is needed.  
* **Synthesis** – This code is fully synthesizable on any standard FPGA/ASIC target.  

Feel free to instantiate `TopModule` in a larger design or write a testbench to verify its behavior.