Here is a compact, synthesizable implementation that satisfies all the requirements:

```verilog
// 8‑bit register made of 8 D‑flip‑flops
// • Active‑high synchronous reset
// • Reset value = 8'h34 (0011 0100)
// • Triggered on the negative edge of clk
module TopModule (
    input          clk,    // clock
    input  [7:0]   d,      // data input
    input          reset,  // active‑high synchronous reset
    output reg [7:0] q      // 8‑bit output (register)
);

    // Negative‑edge triggered, synchronous reset
    always @(negedge clk) begin
        if (reset)          // synchronous reset
            q <= 8'h34;     // reset to 0x34
        else
            q <= d;         // normal data transfer
    end

endmodule
```

### Why this works

| Feature | Implementation |
|---------|----------------|
| **8 D‑FFs** | The vector `q` is 8 bits wide; each bit behaves as an independent D‑FF. |
| **Active‑high synchronous reset** | The `if (reset)` test is inside the `always @(negedge clk)` block, so the reset is sampled on the clock edge. |
| **Reset value 0x34** | `8'h34` is the 8‑bit constant `0011 0100`. |
| **Negative‑edge trigger** | `always @(negedge clk)` ensures the flip‑flops capture data on the falling edge of `clk`. |

This single always‑block is equivalent to instantiating eight separate D‑FF primitives, but it is more concise and easier to maintain. If you prefer explicit instantiation, you can replace the block with eight instances of a simple D‑FF module that follows the same logic.