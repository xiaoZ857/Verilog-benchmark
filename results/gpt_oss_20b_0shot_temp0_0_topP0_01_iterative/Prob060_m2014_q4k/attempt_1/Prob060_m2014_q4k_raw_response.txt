Here is a compact, synthesizable implementation of a 4‑bit shift register with a synchronous, active‑low reset.  
The register is updated on the rising edge of **clk**; when **resetn** is low the register is cleared to zero.  
The output **out** is the most‑significant bit of the shift register (the output of the last D‑flip‑flop).

```verilog
// ------------------------------------------------------------
// 4‑bit shift register (synchronous active‑low reset)
// ------------------------------------------------------------
module TopModule (
    input  wire clk,      // Clock (positive edge triggered)
    input  wire resetn,   // Active‑low synchronous reset
    input  wire in,       // Serial data input
    output wire out       // Serial data output (MSB of the register)
);

    // 4‑bit shift register
    reg [3:0] shift_reg;

    // Synchronous logic
    always @(posedge clk) begin
        if (!resetn)                // active‑low reset
            shift_reg <= 4'b0;      // clear all bits
        else
            shift_reg <= {shift_reg[2:0], in}; // shift left, insert new bit
    end

    // Output is the MSB of the register
    assign out = shift_reg[3];

endmodule
```

### How it works
1. **Clock edge** – On every rising edge of `clk`, the `always` block executes.  
2. **Reset** – If `resetn` is low (`0`), the register is cleared to `4'b0`.  
3. **Shift** – Otherwise, the current contents of the register are shifted left by one bit, and the new input `in` is placed into the least‑significant bit.  
4. **Output** – The most‑significant bit (`shift_reg[3]`) is continuously driven to the module output `out`.

This module satisfies the requirement of