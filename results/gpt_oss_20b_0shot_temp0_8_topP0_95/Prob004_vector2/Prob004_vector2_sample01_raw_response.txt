Below is a straightforward **combinational** implementation that swaps the four bytes of a 32‑bit vector – i.e. it reverses the byte order.  
Because no clock is supplied in the interface, the operation is purely combinational (no registers are used).  

```verilog
// 32‑bit byte‑order reverse
//   in  = [31:24][23:16][15:8][7:0]   (MSB … LSB)
//   out = [7:0][15:8][23:16][31:24]   (reversed)
module TopModule (
    input  wire [31:0] in,
    output wire [31:0] out
);

    // Assign each byte of the output to the corresponding byte of the input
    assign out[31:24] = in[7:0];
    assign out[23:16] = in[15:8];
    assign out[15:8]  = in[23:16];
    assign out[7:0]   = in[31:24];

endmodule
```

### Why this works

* The `assign` statements create continuous, combinational connections.  
* `out[31:24]` (MSB byte of the output) receives `in[7:0]` (LSB byte of the input).  
* Similarly, each middle byte is swapped, and the LSB byte of the output receives the MSB byte of the input.  

No clock or state is required, so the design is fully combinational and synthesizable on any standard FPGA or ASIC target.