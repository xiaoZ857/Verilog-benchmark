**Verilog implementation**

```verilog
// TopModule – ringer / vibration motor controller
//
//   ring          :  incoming call ring pulse (high → phone must ring)
//   vibrate_mode  :  1 = vibrate mode, 0 = normal ringing mode
//
//   ringer        :  drives the phone’s speaker (1 = on)
//   motor         :  drives the vibration motor (1 = on)
//
//   Behaviour:  When `ring` is asserted, either the ringer or the motor
//   is enabled – never both.  In vibrate mode the motor is used,
//   otherwise the ringer is used.  When `ring` is low, both outputs
//   are forced to 0.
//
//   The design is purely combinational – no clock is required.
//   (If a synchronous latch/flip‑flop is desired the logic can be
//   wrapped in an always @* block.)

module TopModule (
    input  wire ring,          // incoming call ring pulse
    input  wire vibrate_mode,  // 1 = vibrate mode
    output wire ringer,        // ringer output
    output wire motor          // vibration motor output
);

//  Only one of the outputs can be high at any time.
//  The following assignments implement the desired behaviour.
assign ringer = ring & ~vibrate_mode;  // ringer on if ring & not vibrate
assign motor  = ring & vibrate_mode;   // motor on if ring & vibrate

endmodule
```

**Explanation**

* The module has no clock input – the logic is purely combinational.
* `assign` statements create continuous assignments that are updated
  immediately when any of their operands change.
* `ringer` is high only when a ring pulse is active **and** the phone is
  **not** in vibrate mode (`~vibrate_mode`).
* `motor` is high only when a ring pulse is active **and** the phone
  **is** in vibrate mode.
* Because the two conditions are mutually exclusive (`vibrate_mode`
  cannot be both 0 and 1 simultaneously), the outputs can never be
  high at the same time.

Feel free to wrap the logic in an `always @*` block if you prefer a
different coding style; the functionality remains identical.