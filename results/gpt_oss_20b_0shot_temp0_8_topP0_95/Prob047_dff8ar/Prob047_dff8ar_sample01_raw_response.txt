Here is a concise, synthesizable Verilog implementation that meets all of the stated requirements:

```verilog
// ---------------------------------------------------------------
// 8‑bit register (8 D‑flip‑flops) with active‑high asynchronous reset
// ---------------------------------------------------------------
//  - All FFs are edge‑triggered on the positive edge of `clk`
//  - Asynchronous reset (`areset`) is active high
//  - When reset is asserted, `q` is forced to 8'b0
// ---------------------------------------------------------------

module TopModule (
    input  wire        clk,     // Clock (positive‑edge triggered)
    input  wire [7:0]  d,       // Data input
    input  wire        areset,  // Active‑high asynchronous reset
    output reg  [7:0]  q        // Registered output
);

    // Synchronous behavior with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if (areset)          // Asynchronous reset
            q <= 8'b0;       // Reset output to 0
        else
            q <= d;          // Capture data on clock edge
    end

endmodule
```

### Why this works

* **Asynchronous reset** – The `always @(posedge clk or posedge areset)` sensitivity list guarantees that the reset logic fires immediately when `areset` goes high, regardless of the clock.
* **Positive‑edge clock** – The `posedge clk` clause ensures that the data is latched on the rising edge of the clock.
* **8 D‑FFs** – The 8‑bit register `q` effectively consists of 8 independent D‑flip‑flops; each bit is independently reset and updated.
* **Reset to 0** – On reset, `q` is explicitly set to `8'b0`, satisfying the requirement that the output be reset to 0.

This module is fully synthesizable and follows common Verilog coding style conventions.