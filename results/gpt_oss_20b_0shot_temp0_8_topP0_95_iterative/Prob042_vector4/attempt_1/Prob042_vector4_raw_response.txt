**Solution – 8‑bit to 32‑bit sign‑extension**

```verilog
// TopModule.v
//
//  Sign‑extend an 8‑bit value (in) to 32 bits (out).
//  The 8‑bit input is assumed to be a signed two‑s complement number
//  (bit[7] is the sign bit).  The output is simply the sign bit replicated
//  24 times followed by the original 8 bits.
//
//  This is a combinational circuit – the output follows the input
//  immediately on the next clock edge (or right after the input changes
//  if the design is purely combinational).

module TopModule (
    input  wire [7:0]  in,   // 8‑bit signed input
    output wire [31:0] out   // 32‑bit sign‑extended output
);

//  Use the replication operator to repeat the sign bit 24 times
//  and concatenate it with the original 8‑bit vector.
assign out = {24{in[7]}, in};

endmodule
```

### Why this works

* `in[7]` is the most‑significant bit (MSB) of the 8‑bit input – the sign bit in two‑complement representation.
* `{24{in[7]}}` creates a 24‑bit vector where every bit equals the sign bit.
* Concatenation `{ … , … }` puts the 24‑bit vector on the left and the 8‑bit input on the right, forming a 32‑bit vector.
* Because the replication operator is purely combinational, the output updates as soon as the input changes, making the module fully synthesizable for any FPGA or ASIC target.

Feel free to add a `signed` attribute to the ports if you want the tool to treat them as signed numbers, but the functional behaviour is already correct with the code above.