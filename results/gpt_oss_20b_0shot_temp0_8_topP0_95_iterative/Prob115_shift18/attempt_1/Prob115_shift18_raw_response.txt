Below is a compact, synthesizable implementation that follows the specification:

```verilog
// 64‑bit arithmetic shift register with synchronous load
// -----------------------------------------------------
//  • load  – when high, q is loaded with data[63:0] on the next rising edge
//  • ena   – when high (and load is low) the shift operation is performed
//  • amount – selects the direction and size of the shift
//      2'b00 : shift left  by 1
//      2'b01 : shift left  by 8
//      2'b10 : shift right (arithmetic) by 1
//      2'b11 : shift right (arithmetic) by 8
//
//  The shift is synchronous to the rising edge of clk.
module TopModule (
    input  wire        clk,          // clock
    input  wire        load,         // synchronous load
    input  wire        ena,          // enable shift
    input  wire [1:0]  amount,       // shift amount/direction
    input  wire [63:0] data,         // data to load
    output reg  [63:0] q             // shift register contents
);

    // Synchronous process
    always @(posedge clk) begin
        if (load) begin
            // Load path (takes priority over shifting)
            q <= data;
        end
        else if (ena) begin
            // Shift path
            case (amount)
                2'b00: q <= q << 1;                         // left by 1
                2'b01: q <= q << 8;                         // left by 8
                2'b10: q <= $signed(q) >> 1;                // arithmetic right by 1
                2'b11: q <= $signed(q) >> 8;                // arithmetic right by 