Here's a Verilog module that implements the described D flip-flop array:

```verilog
module TopModule (
  input clk,
  input resetn,
  input [1:0] byteena,
  input [15:0] d,
  output reg [15:0] q
);

reg [7:0][15:0] q[16:0];

always @(posedge clk) begin
    if (!resetn) begin
        for (int i = 0; i < 17; i++) begin
            q[i] <= 1'b0;
        end
    end else begin
        for (int i = 0; i < 16; i++) begin
            if (byteena[0][i] == 1) begin
                q[i + 8] <= d[i];
            end
            if (byteena[1][i] == 1) begin
                q[i] <= d[i + 8];
            end
        end
    end
end

assign q[0] = q[16];
assign q[1] = q[15];

endmodule
```

This module creates a 17-bit wide array of D flip-flops, where the lower byte is controlled by `byteena[0]` and the upper byte is controlled by `byteena[1]`. The `resetn` input is used to reset all flip-flops simultaneously. The output `q` is also assigned in a way that makes it easier to access individual bits of the array.

Note: In Verilog, we use the `reg` keyword to declare registers, and the `always` keyword to specify the conditions under which they should be updated. We use the `posedge` keyword to indicate that the update should occur on the positive edge of the clock signal.