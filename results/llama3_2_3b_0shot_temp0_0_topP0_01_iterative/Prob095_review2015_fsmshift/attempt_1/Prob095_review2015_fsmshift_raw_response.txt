Here's a Verilog module that implements the described behavior:

```verilog
module TopModule(
    input clk,
    input reset,
    output shift_ena
);

    // Internal signals for state machine
    reg [1:0] state;
    reg [3:0] counter;

    // Initialize internal signals on reset
    always @(reset) begin
        state <= 2'b00; // Reset to initial state
        counter <= 4'd0; // Reset counter to 0
    end

    // State machine logic
    always @(posedge clk) begin
        if (reset) begin
            state <= 2'b00;
            counter <= 4'd0;
        end else if (state == 2'b01 && counter < 4'd3) begin
            state <= 2'b10; // Move to next state
            counter <= counter + 1;
        end else if (state == 2'b10 && counter == 4'd3) begin
            state <= 2'b00; // Reset state machine
            counter <= 4'd0;
            shift_ena <= 1'b1; // Enable shift register for 4 clock cycles
        end else if (state != 2'b01) begin
            state <= 2'b00; // Stay in reset state
            counter <= 4'd0;
        end
    end

    // Output logic
    always @(posedge clk) begin
        shift_ena <= !reset && (state == 2'b01 || state == 2'b10);
    end

endmodule
```

This module uses a finite state machine to track the current state and counter. The `shift_ena` output is asserted when the proper bit pattern is detected, which happens in the second state (`2'b10`). After four clock cycles, the state machine resets back to its initial state (`2'b00`) and the `shift_ena` output goes low.

The module also asserts `shift_ena` for 4 clock cycles whenever the reset signal is active high.