Here is a Verilog implementation of the described module:

```verilog
module TopModule(
    input clk, // Positive clock/clk triggered
    input load, // Synchronous active high
    input [1:0] ena, // Synchronous
    input [99:0] data, // 100-bit left/right rotator
    output reg [99:0] q // The contents of the rotator
);

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end else if (ena == 2'b01) begin // Rotate right by one bit
            q <= {data[99], data[98:0]};
        end else if (ena == 2'b10) begin // Rotate left by one bit
            q <= {data[1:0], data[99:98]};
        end else begin // Do not rotate
            q <= data;
        end
    end

endmodule
```

This module uses a combinational logic block to implement the rotation. The `ena` signal is used to determine which direction of rotation should be applied, and the `load` signal is used to load the shift register with new data.

The rotation is implemented using bit shifting operations. When rotating right by one bit (`ena == 2'b01`), the last bit of the data is moved to the front, while when rotating left by one bit (`ena == 2'b10`), the first bit of the data is moved to the back. If `ena` is not one of these values, no rotation occurs.

Note that this implementation assumes that the input data is a 100-bit binary number. The output `q` will also be a 100-bit binary number.