Here's a Verilog module implementation of the described finite state machine:

```verilog
module TopModule(
    input clk, // Positive edge triggered clock
    input reset, // Active high synchronous reset
    input s,     // Input signal for state A
    input w,     // Input signal for states B and C
    output reg z  // Output signal to be set based on the FSM's state
);

reg [1:0] state; // State of the finite state machine

always @(posedge clk) begin
    if (reset) begin
        state <= 2'b00; // Reset to state A
    end else if (~s && w == 1) begin
        state <= 2'b01; // Move to state B
    end else if (state == 2'b01) begin
        state <= {w, state[0]}; // Update state based on w and previous state
    end else if (state == 2'b10 || state == 2'b11) begin
        z <= (state[1] && ~state[0]); // Set z to 1 if two consecutive w=1
        state <= {w, state[0]}; // Update state based on w and previous state
    end else if (state == 2'b00) begin
        state <= 2'b01; // Move to state B
    end
end

assign z = z;

endmodule
```

This module uses a minimal number of states, as required. The `state` variable is used to track the current state of the finite state machine.

The FSM starts in state A when the reset signal is active high. When `s` is 0 and `w` is 1, it moves to state B. In state B, it checks the value of `w` for three consecutive clock cycles. If `w` is 1 exactly two times, it sets the output `z` to 1 in the next clock cycle. Otherwise, `z` remains 0.

The FSM continues this process indefinitely, with the state being updated based on the current values of `s`, `w`, and the previous state.