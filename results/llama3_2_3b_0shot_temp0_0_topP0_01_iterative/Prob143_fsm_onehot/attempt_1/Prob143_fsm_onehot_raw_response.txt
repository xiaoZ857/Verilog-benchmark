Here is the Verilog implementation of the state machine:

```verilog
module TopModule(
    input clk, // Assuming a positive clock edge
    input in,
    output reg [9:0] next_state,
    output reg out1,
    output reg out2
);

// State transition logic
reg [9:0] state_next;
assign next_state = state;

always @(posedge clk) begin
    if (in == 0) begin // Falling edge
        for (int i = 0; i <= 9; i++) begin
            if (state[i] == 1) begin
                next_state[i] = 0;
            end else if (i < 5 && state[4-i] == 1) begin
                next_state[i] = 1;
            end else if (i >= 5 && state[9-i] == 1) begin
                next_state[i] = 1;
            end
        end
    end else if (in == 1) begin // Rising edge
        for (int i = 0; i <= 9; i++) begin
            if (state[i] == 1) begin
                next_state[i] = 0;
            end else if (i < 5 && state[4-i] == 0) begin
                next_state[i] = 1;
            end else if (i >= 5 && state[9-i] == 0) begin
                next_state[i] = 1;
            end
        end
    end
end

// Output logic
assign out1 = next_state[4];
assign out2 = next_state[8];

endmodule
```

This implementation assumes a positive clock edge and uses one-hot encoding for the states. The state transition logic is implemented using a combination of `if` statements to check the current state and input, and then updating the next state accordingly. The output logic simply assigns the values of the two outputs based on the corresponding bits in the `next_state` register.

Note that this implementation does not include any error checking or handling for invalid inputs. In a real-world application, you would want to add checks to ensure that the input is valid and within the expected range.