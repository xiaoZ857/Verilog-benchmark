Here's the Verilog code for the top-level module implementing the specified shift register:

```verilog
module TopModule(
    input clk, // clock signal
    input resetn, // active-low synchronous reset
    input in,      // input to the shift register
    output out     // output of the shift register
);

// Define the internal signals for the D flip-flops
reg[3:0] shiftReg;

// Initialize the registers with 0 (assuming the initial value is 0)
initial begin
    $display("Initializing the shift register...");
    for (int i = 0; i < 4; i++) {
        shiftReg[i] = 0;
    }
end

always @(posedge clk) begin
    // Update the shift register on every clock edge
    if (!resetn) begin
        // Clear the register when reset is asserted
        shiftReg[0:3] <= 4'd0;
    end else if (in != shiftReg[0]) begin
        // Shift out the next bit and clear the oldest one
        for (int i = 3; i > 0; i--) {
            shiftReg[i] <= shiftReg[i - 1];
        }
        shiftReg[0] <= in;
    end
end

assign out = shiftReg;

endmodule
```

This implementation provides a basic shift register with four D flip-flops. The clock edge is always triggered, meaning the module changes its state on every rising edge of the input signal `clk`. This means that it will work correctly if the input is active-low.

The register uses an active-low synchronous reset when the input `resetn` is low (`0`). When this happens, all four flip-flops are cleared to zero. If the input `in` changes and also different from the current value in the shift register, then a bit shifts to the right, and the oldest one is cleared.

The output of the module can be connected to other modules or used directly as needed by your design.