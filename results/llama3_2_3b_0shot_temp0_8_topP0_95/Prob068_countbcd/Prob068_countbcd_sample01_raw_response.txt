Here is the Verilog module implementation for a 4-digit BCD counter:
```verilog
module TopModule(
    input clk,        // System clock signal (active-high)
    input reset,       // System reset signal (active-low)
    output [3:1] ena,   // Enable signals for upper digits
    output reg [15:0] q // BCD counter value
);

    parameter NUM_DIGITS = 4;

    wire [NUM_DIGITS*4-1:NUM_DIGITS-1][NUM_DIGITS-1:0] bcd_inputs;
    reg [NUM_DIGITS*4-1:NUM_DIGITS-1] count;

    assign {
        // Reset the counter
        : ena = 1'b0; 
        : q = 16'd0; 
    } when (reset);

    always @(posedge clk) begin
        if (ena == 1'b0) begin
            ena <= 1'b1;
            count[2:0] <= count[3:1];
            count[NUM_DIGITS-1:NUM_DIGITS*4-1] <= {count[NUM_DIGITS*4-2:NUM_DIGITS], count[NUM_DIGITS*4-2:NUM_DIGITS]};
        end else begin
            if (count[NUM_DIGITS-1] == 16'd9) begin
                // All digits are counted, reset and wrap around
                ena <= 1'b0;
                count[0:NUM_DIGITS-1] <= {15'd0, count[0:NUM_DIGITS-2]};
            end else if (count[NUM_DIGITS-1] > 16'd9) begin 
                // Count wraps around
                ena <= 1'b0;
                count[NUM_DIGITS-1] <=  count[NUM_DIGITS*4-1];
                count[0:NUM_DIGITS-1] <= {15'd0, count[0:NUM_DIGITS-2]};
            end else begin 
                // Increment the current digit
                if (count[NUM_DIGITS*4-count[NUM_DIGITS-1]:NUM_DIGITS*3-count[NUM_DIGITS-2]] == 16'd9) 
                    ena <= 1'b0;
                count[NUM_DIGITS*4-count[NUM_DIGITS-1]:NUM_DIGITS*3-count[NUM_DIGITS-2]] <= {count[NUM_DIGITS*4-count[NUM_DIGITS-1]-1:NUM_DIGITS*3-count[NUM_DIGITS-2]-1], 16'd0}; 
                count[NUM_DIGITS*4-count[NUM_DIGITS-1]:NUM_DIGITS*3-count[NUM_DIGITS-2]] <= {count[NUM_DIGITS*4-count[NUM_DIGITS-1]-1:NUM_DIGITS*3-count[NUM_DIGITS-2]-1], 16'd0}; 
                count[0:NUM_DIGITS] <= (count[1:NUM_DIGITS] + 1);
            end
        end
    end

endmodule
```

The Verilog code implements a synchronous active-high reset and outputs an enable signal for each of the upper digits. The `ena` output is a vector containing three elements, where the first element corresponds to the tens digit, the second element corresponds to the ones digit, and the third element corresponds to the two's place digit.

In this module, we use a counter with 16 bits to keep track of the BCD value. When the clock signal is rising (i.e., `ena == 1'b0`), we increment the current digit and wrap around if necessary. The enable signals are set to 1 when all digits are counted (`ena = 1'b0`) or when a digit wraps around.

Note: This implementation uses a simplified BCD counter design that may not be suitable for high-speed applications due to its simplicity.