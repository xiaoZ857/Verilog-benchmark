To implement a dual-edge triggered flip-flop (DFTF) in Verilog, we need to use two separate flip-flops that are triggered on both positive and negative edges of the clock. Here's an example implementation:

```verilog
module DualEdgeTriggeredFlipFlop (
  input clk,
  input d,
  output reg q1,
  output reg q0
);

  always @(posedge clk)
    begin
      // Triggering on positive edge
      q1 <= d;
    end

  always @(negedge clk)
    begin
      // Triggering on negative edge
      q0 <= d;
    end

endmodule
```

However, since FPGAs don't support dual-edge triggered flip-flops, we can use two separate DFFs to achieve the same functionality:

```verilog
module DualEdgeTriggeredFlipFlop (
  input clk,
  input d,
  output reg q1,
  output reg q0
);

  DualEdgeTriggeredFlipFlop dff1(
    .clk(clk),
    .d(d),
    .q(q1)
  );

  DualEdgeTriggeredFlipFlop dff2(
    .clk(clk),
    .d(d),
    .q(q0)
  );

endmodule
```

In this implementation, we're using two separate DFFs (`dff1` and `dff2`) that are triggered on both positive and negative edges of the clock. The outputs `q1` and `q0` represent the current states of these two DFFs.

Here's a more efficient way to implement the dual-edge trigger:

```verilog
module DualEdgeTriggeredFlipFlop (
  input clk,
  input d,
  output reg q1,
  output reg q0
);

  reg [1:0] prev_state;
  assign prev_state = {q1, q0};

  always @(posedge clk)
    begin
      // Triggering on positive edge
      if (~prev_state[0]) q1 <= d;
      else q0 <= d;

      // Triggering on negative edge
      if (~prev_state[1]) q0 <= d;
      else q1 <= d;
    end

endmodule
```

In this implementation, we're using a single DFF (`q`) and two registers to store the previous states. We update the current state based on the previous state and the input `d`. This approach reduces the number of DFFs required and is more efficient in terms of area and clock cycles consumed.

```verilog
module DualEdgeTriggeredFlipFlop (
  input clk,
  input d,
  output reg q
);

  reg [1:0] prev_state;
  assign prev_state = {q, ~q};

  always @(posedge clk)
    begin
      // Triggering on positive edge
      if (~prev_state[0]) q <= d;
      else q <= d;

      // Triggering on negative edge
      if (~prev_state[1]) q <= d;
      else q <= d;
    end

endmodule
```