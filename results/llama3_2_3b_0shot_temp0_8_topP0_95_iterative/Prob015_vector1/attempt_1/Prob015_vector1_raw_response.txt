Here's a simple Verilog module that performs the required split:

```verilog
module TopModule (
  input [15:0] in,
  output [7:0] out_hi,
  output [7:0] out_lo
);

// Half word size is defined as 16 bits
#define HALF_WORD_SIZE 16

// Upper byte size is defined as 8 bits
#define UPPER_BYTE_SIZE 8

// Lower byte size is defined as 8 bits
#define LOWER_BYTE_SIZE 8

assign out_hi = in[UPPER_BYTE_SIZE-1:0];
assign out_lo = in[LOWER_BYTE_SIZE-1:UPPER_BYTE_SIZE-UPPER_BYTE_SIZE];

endmodule
```

This module works by using the `assign` keyword to directly assign values to the `out_hi` and `out_lo` signals based on the bit positions of the input half-word.

Here's how it works:

*   The upper byte (`out_hi`) is assigned from bits `[UPPER_BYTE_SIZE-1:0]`, which corresponds to the last 8 bits of the input half-word.
*   The lower byte (`out_lo`) is assigned from bits `[LOWER_BYTE_SIZE-1:UPPER_BYTE_SIZE-UPPER_BYTE_SIZE]`, which corresponds to the first 8 bits of the input half-word.

The Verilog module defines `UPPER_BYTE_SIZE` and `LOWER_BYTE_SIZE` as constants for better readability. However, it's worth noting that you can also use simple bit masks or arithmetic operations to achieve the same result without defining these constants:

```verilog
module TopModule (
  input [15:0] in,
  output [7:0] out_hi,
  output [7:0] out_lo
);

assign out_hi = in[UPPER_BYTE_SIZE-1:0];
assign out_lo = in[15:UPPER_BYTE_SIZE];

endmodule
```