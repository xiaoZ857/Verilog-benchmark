Here is the Verilog module implementation:

```verilog
module TopModule (
  input [7:0] a,
  input [7:0] b,
  output [7:0] s,
  output logic overflow
);
  
signed [7:0] sum_a_b;

always_comb begin
  // Calculate the sum of a and b using binary addition
  sum_a_b = a + b;
end

assign s[1:0] = |sum_a_b; // get two least significant bits of sum (2's complement)
if(|sum_a_b>127) overflow <= 1; else overflow <= 0;

endmodule
```

Note that the `|` operator is used to check for overflow in 2's complement system. It returns 1 if there is an overflow, and 0 otherwise.

Here's a brief explanation:

- The `signed [7:0] sum_a_b` variable is used to hold the result of the addition of `a` and `b`. Since we're using 2's complement arithmetic for signed numbers, the most significant bit represents the sign.
- In binary addition, if the sum of two bits exceeds `1111`, an overflow occurs. However, in 2's complement representation, this is equivalent to a sign change from positive to negative or vice versa. Therefore, we can use the bitwise OR operator (`|`) to check for overflow.
- If the result of adding `a` and `b` results in a value greater than `1111`, then an overflow has occurred. We set the `overflow` signal to 1 in this case; otherwise, it's set to 0.

Example use case:
```verilog
module TestModule;
  
reg [7:0] a = 10000000; // decimal: 128
reg [7:0] b = 20000000; // decimal: 256
reg [7:0] s;
reg logic overflow;

TopModule top_module(
    .a(a),
    .b(b),
    .s(s),
    .overflow(overflow)
);

initial begin
  #100 top_module.s = 6; // decimal: -126
  $display("Overflow status: %d", top_module.overflow);
end

endmodule
```
This code simulates a test module that connects `a` and `b` to the input of `TopModule`, then assigns `s` to be `-126`. It waits for `100` clock cycles, then displays whether an overflow occurred.

Note: The output of the example code will display "Overflow status: 1" indicating that there was a signed overflow.