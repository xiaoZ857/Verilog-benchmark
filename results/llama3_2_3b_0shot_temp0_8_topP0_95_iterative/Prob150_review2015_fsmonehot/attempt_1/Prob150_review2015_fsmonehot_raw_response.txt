Here's the implementation of the Moore state machine in Verilog:

```verilog
module TopModule(
    input d, // Input signal 'd'
    input done_counting, // Input signal 'done_counting'
    input ack, // Input signal 'ack'
    input [9:0] state, // 10-bit one-hot current state
    output B3_next, // Output signal 'B3_next'
    output S_next, // Output signal 'S_next'
    output S1_next, // Output signal 'S1_next'
    output Count_next, // Output signal 'Count_next'
    output Wait_next, // Output signal 'Wait_next'
    output done, // Output logic 'done'
    output counting, // Output logic 'counting'
    output shift_ena  // Output logic 'shift_ena'
);

// Define the states
parameter [9:0] S = {1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0};
parameter [9:0] S1 = {1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h1};
parameter [9:0] S11 = {1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h1, 1'h0};
parameter [9:0] S110 = {1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h1, 1'h0, 1'h0};
parameter [9:0] B0 = {1'h0, 1'h0, 1'h0, 1'h1, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0};
parameter [9:0] B1 = {1'h0, 1'h0, 1'h0, 1'h1, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h1};
parameter [9:0] B2 = {1'h0, 1'h0, 1'h0, 1'h1, 1'h0, 1'h0, 1'h0, 1'h0, 1'h1, 1'h0};
parameter [9:0] B3 = {1'h0, 1'h0, 1'h0, 1'h1, 1'h0, 1'h0, 1'h0, 1'h0, 1'h1, 1'h1};
parameter [9:0] Count = {1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h1, 1'h1, 1'h0};
parameter [9:0] Wait = {1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h0, 1'h1};

// Define the state transition logic
assign B3_next = (state == B3);
assign S_next = (state == S);
assign S1_next = (state == S1);
assign Count_next = (state == Count);

// Define the output logic based on state transitions
always_comb begin : OUTPUT_LOGIC
    assign done = ((state == Wait) && ack != 0) || (state == B3);
    assign counting = (done == 0) ? (state == Count) : 1'b0;
    assign shift_ena = (state != B3) ? 1'b0 : 1'b1;
end

endmodule
```

In this code, we define the states and their corresponding one-hot encodings. We then use assign statements to implement the state transition logic for each output signal.

Note that the combinational logic portion of the state machine is implemented using a single always_comb block. This block is used to calculate the output signals based on the current state and other inputs.

Please note that this implementation assumes that you are familiar with Verilog programming language and one-hot encoding concepts.