 Here is the Verilog code for the Rule 110 cellular automaton as per your description:

```verilog
module TopModule (
  input clk,
  input load,
  input [511:0] data,
  output reg [511:0] q
);

// Define the next state function for each cell based on Rule 110
function next_state_rule110
(
  input [2:0] current_cell_and_neighbors
) returns {
  reg next_state;

  assign next_state = (current_cell_and_neighbors == 3'b110 || current_cell_and_neighbors == 3'b111);

  return next_state;
};

// Initialize the q array with zeros
always_comb begin
  assign q = 512'b0;
end

// Load data into q when load is high
always @(posedge clk) begin
  if (load) begin
    q <= data;
  end
end

// Advance the state of each cell in q based on Rule 110
always @(posedge clk) begin
  integer i;

  for (i = 0; i < 512; i = i + 1) begin
    assign q[i] = next_state_rule110((q[i-1]<0?0:q[i-1]) | q[i] | (q[i+1]<513?q[i+1]:0));
  end
end

endmodule
```

This code initializes the `q` array with zeros, loads data into it when the `load` input is high, and advances the state of each cell in `q` based on Rule 110 at every clock cycle. The `next_state_rule110` function calculates the next state for a given cell and its neighbors according to the table provided in your description.