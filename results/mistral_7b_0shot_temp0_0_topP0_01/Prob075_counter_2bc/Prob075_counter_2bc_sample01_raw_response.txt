 Here's the Verilog code for the two-bit saturating counter as per your description:

```verilog
module TopModule (
  input wire clk,
  input wire areset,
  input wire train_valid,
  input wire train_taken,
  output logic [1:0] state
);

reg [1:0] counter; // Declare a register for the counter
always @(posedge clk) begin
  if (areset) begin // On positive edge of clock when areset is high
    counter <= 2'b01; // Reset the counter to weakly not-taken (2'b01)
  end else if (train_valid && train_taken) begin // If training and taken is high
    counter <= counter + 1; // Increment the counter
    if (counter > 3'b11) counter <= 3'b11; // Saturate the counter at 3
  end else if (train_valid && !train_taken) begin // If training and taken is low
    counter <= counter - 1; // Decrement the counter
    if (counter < 2'b00) counter <= 2'b00; // Saturate the counter at 0
  end
end

assign state = counter; // Assign the counter value to output state

endmodule
```

This code defines a module named `TopModule`, which has an input clock, asynchronous reset, train_valid, and train_taken signals, and a two-bit output state. The counter is implemented using a register that increments or decrements based on the train_valid and train_taken signals. The counter is also saturated at 0 and 3 to prevent it from going out of bounds. The final value of the counter is assigned to the output `state`.