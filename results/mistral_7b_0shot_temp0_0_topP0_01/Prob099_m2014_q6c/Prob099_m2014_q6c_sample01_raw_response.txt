 Here is the Verilog code for the next-state signals `Y2` and `Y4` based on the given state machine and one-hot encoding:

```verilog
module TopModule (
  input [6:1] y,
  input w,
  output reg Y2,
  output reg Y4
);

always @(posedge clk) begin
  case (y)
    2'b00 : Y2 <= 2'b0; Y4 <= 2'b0; // A
    2'b01 : Y2 <= 2'b0; Y4 <= 2'b1; // B
    2'b10 : Y2 <= 2'b1; Y4 <= 2'b0; // C
    2'b11 : Y2 <= 2'b1; Y4 <= 2'b1; // D
    default: Y2 <= 2'bx; Y4 <= 2'bx; // Unassigned states (X)
  endcase

  assign w_next = w ^ (y[2] == 1'b1); // Next clock input w is inverted if y[2] is set to 1
endmodule
```

In this code, the `always @(posedge clk)` block represents a positive edge-triggered process. The `case (y)` statement checks the current state based on the one-hot encoding of the `y` input. The logic equations for `Y2` and `Y4` are derived by inspection as shown in the table below:

| y | Y2 | Y4 |
| --- | --- | --- |
| 000001 (A) | 0 | 0 |
| 000010 (B) | 0 | 1 |
| 000100 (C) | 1 | 0 |
| 001000 (D) | 1 | 1 |
| Others (X) | x | x |