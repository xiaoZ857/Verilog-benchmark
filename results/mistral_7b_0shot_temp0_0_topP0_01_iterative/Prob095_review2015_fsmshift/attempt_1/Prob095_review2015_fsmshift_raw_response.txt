 Here's a simple Verilog implementation of the described module:

```verilog
module TopModule (
  input wire clk,
  input wire reset,
  output reg shift_ena
);

reg counter = 4'b0001; // Initialize counter to 1000 (4 in binary)
always @(posedge clk) begin
  if (reset)
    shift_ena <= 1'b1; // Reset: assert shift_ena for 4 cycles
  else if (counter == 4'b0001) // If counter is at its initial value, increment it
    counter <= counter + 1'b1;
  else if (counter > 4'b0001) // If counter is greater than its initial value, decrement it
    counter <= counter - 1'b1;
  shift_ena <= counter[3]; // Output the least significant bit of the counter as shift_ena
end

// To ensure that shift_ena remains at 0 after the 4 cycles, you can add the following always block:
always @(posedge clk) begin
  if (reset)
    shift_ena <= 1'b1; // Reset: assert shift_ena for 4 cycles
  else if (counter == 4'b0001) // If counter is at its initial value, increment it
    counter <= counter + 1'b1;
  else if (counter > 4'b0001) // If counter is greater than its initial value, decrement it
    counter <= counter - 1'b1;
  if (!reset && counter < 4'b0001) // If we are not in reset and the counter is less than 4, assert shift_ena as 0
    shift_ena <= 1'b0;
end
```

This implementation initializes the counter to 1000 (4 in binary), and increments or decrements it based on the positive edge of the clock signal. The `shift_ena` output is set to the least significant bit of the counter, which will be 1 for the first four clock cycles after a reset, and then 0 forever unless another reset occurs.

The second always block ensures that `shift_ena` remains at 0 after the 4 cycles if no reset is asserted.