 Here is a Verilog implementation for the described module:

```verilog
module TopModule (
  input wire clk,
  input wire resetn,
  input [1:0] byteena,
  input [15:0] d,
  output reg [15:0] q
);

reg [15:0] d_upper [15:0]; // store upper byte of data for each DFF
reg [15:0] d_lower [15:0]; // store lower byte of data for each DFF

always @(posedge clk) begin
  if (!resetn) begin
    // reset all flip-flops to zero
    d_upper <= 0;
    d_lower <= 0;
  end else begin
    // set data for upper byte when byteena[1] is high
    if (byteena[1]) d_upper <= d[15:8];

    // set data for lower byte when byteena[0] is high
    if (byteena[0]) d_lower <= d[7:0];
  end
end

assign q = d_upper | d_lower; // concatenate upper and lower bytes to output

endmodule
```

This Verilog module creates two separate registers `d_upper` and `d_lower` to store the data for each of the 16 D flip-flops, based on the `byteena` inputs. The main logic is inside an always block that triggers on the positive edge of the clock signal `clk`. When `resetn` is high (not active), all flip-flop values are reset to zero. Otherwise, if `resetn` is low, the data for each byte is stored in the corresponding register based on the `byteena` inputs. Finally, the output `q` is set to a concatenation of the `d_upper` and `d_lower` registers.