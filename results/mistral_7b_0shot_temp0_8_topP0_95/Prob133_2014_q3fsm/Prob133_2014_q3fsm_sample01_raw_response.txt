 Here is a possible Verilog implementation for the described finite state machine:

```verilog
module TopModule (
  input clk,
  input reset,
  input s,
  input w,
  output reg z
);

reg state = 0; // Initial state is A
reg count_ones = 0; // Counts the number of ones in the last three clock cycles

always @(posedge clk or posedge reset) begin
  if (reset) begin
    state <= 0; // Reset to initial state A
    count_ones <= 0;
    z <= 0;
  end else if (state == 0 && s == 1) begin
    state <= 1; // Transition from A to B when s = 1
  end else if (state == 1) begin
    count_ones <= count_ones << 1; // Shift left the count of ones
    if (w) count_ones += 2'b10; // Add 2 if w is 1
    if (count_ones == 3'b11) z <= 1; // Set z to 1 if count_ones equals 111
    state <= state; // Stay in state B
  end
end

always @(posedge clk or posedge reset) begin
  if (state >= 2 && s == 0) state <= 0; // Return to state A when s = 0
end

initial begin
  $dumpfile("output.vcd");
  $dumpvars(0, TopModule);
  clk = 1'b0;
  forever #5 clk = ~clk;
end
```

This implementation models a synchronous finite state machine with two states (A and B) as described in the problem statement. The FSM has an input `s`, which controls the transition from A to B when it is high, and an input `w`, which is checked during three consecutive clock cycles while in state B. If `w` equals 1 in exactly two of those clock cycles, then `z` will be set to 1 in the following clock cycle.

To test this FSM, I've added a `initial` block that generates a test clock signal and prints the simulation waveforms into a VCD (Value Change Dump) file named "output.vcd". You can use tools like GTKWave to visualize these waveforms during simulation.