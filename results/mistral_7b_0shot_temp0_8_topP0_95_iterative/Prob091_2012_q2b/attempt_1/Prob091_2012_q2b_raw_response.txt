 Here is the Verilog code for the given state machine with the specified one-hot encoding:

```verilog
module TopModule (
  input [5:0] y,
  input w,
  output Y1,
  output Y3
);

reg [4:0] state; // State variable
assign Y1 = state[1]; // Y1 is the output of state flip-flop y[1]
assign Y3 = state[3]; // Y3 is the output of state flip-flop y[3]

always @(posedge w) begin
  case (state) // Check current state and determine next state
    4'b00001 : state <= 4'b00000; // A -> A or B
    4'b00010 : state <= 4'b00001; // A -> B
    4'b00100 : state <= 4'b00100; // B -> D or C
    4'b01000 : state <= 4'b00101; // B -> C
    4'b10000 : state <= 4'b10000; // C -> E or F
    4'b00011 : state <= 4'b01000; // C -> D (This should be 4'b01000, but it leads to a cycle. Here we handle the transition to avoid the cycle.)
    4'b10001 : state <= 4'b10000; // D -> F or E
    4'b01001 : state <= 4'b10001; // D -> F
    default   : state <= 4'b00000; // Any other state leads to A
  endcase
end
```

In this code, we initialize the `state` variable and assign the outputs `Y1` and `Y3`. The always block contains a case statement that checks the current state of the state machine and determines the next state based on the given transitions. Note that we handle the transition from C -> D (4'b00011) separately to avoid a cyclic behavior in the state machine.