 Here is a Verilog implementation of the Rule 90 cellular automaton with a 512-cell system. The boundaries are assumed to be zero (off) as specified in the problem statement.

```verilog
module TopModule (
  input clk,
  input load,
  input [511:0] data,
  output reg [511:0] q
);

reg [512:0] next_state;

always @(posedge clk) begin
    if (load)
        next_state <= data; // Load new state
    else
        begin
            for (int i = 0; i < 512; i++)
                next_state[i] = q[(i-1+512)%512] ^ q[(i+1)%512]; // Apply Rule 90
        end
    assign q = next_state; // Assign new state to q
end

initial begin
    initial_state: for (int i = 0; i < 512; i++)
        next_state[i] <= 0; // Initialize all cells to off
end

// Initialization of the first state
always @(posedge clk) if (load && posedge $time > 0)
    initial_state; // Set the state after the first clock tick

// Boundary conditions
assign q[-1] = 0;
assign q[512] = 0;

endmodule
```

This Verilog module defines a TopModule with inputs `clk`, `load`, `data`, and output `q`. The initial state of the cells is zero (off). At each clock cycle, the next state of each cell is calculated based on Rule 90 using its two neighbors. If the load input is high, the data input will be loaded into the next_state register at the beginning of each clock cycle.