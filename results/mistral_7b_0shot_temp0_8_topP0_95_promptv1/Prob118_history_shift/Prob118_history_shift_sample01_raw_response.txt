 ```verilog
reg [31:0] history_reg [32-1:0]; // 32-bit global history shift register
reg counter; // counter for shifting the history
reg flush; // flag for pipeline flush

always @(posedge clk or negedge areset) begin
    if (areset) begin
        counter <= 0;
        flush <= 1'b0; // no pipeline flush on reset
    end else if (!flush) begin
        if (counter < 32) begin
            history_reg[counter] <= predict_taken; // shift in predict_taken during prediction
            counter++;
        end
    end
end

always @(posedge clk) begin
    if (predict_valid && !flush) begin
        history_reg[0] <= predict_taken; // update the youngest branch history
    end else if (train_mispredicted) begin
        flush <= 1'b1; // pipeline flush on misprediction
        counter <= 0;
        history_reg <= train_history; // load the branch history register with train_history
    end
end

assign predict_history = history_reg[31:0]; // wire output using assign statement
```

Verification checklist:
- Code ends with `endmodule`
- All wire outputs use `assign` keyword (predict_history)
- All reg outputs are assigned in always blocks (history_reg, counter, flush)
- Only declared signals are used (clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history)
- Blocking/non-blocking assignments are correct