To implement an XOR gate in three different ways using Verilog, we can use the following approach:

1. **Using `assign` statement**: This will create a combinational logic for the XOR operation.
2. **Using a combinational `always` block**: This is another way to describe combinational logic.
3. **Using a clocked `always` block**: This introduces a flip-flop, causing the output to be delayed by one clock cycle.

Here's how you can implement these in a Verilog module:

```verilog
module TopModule (
  input clk,
  input a,
  input b,
  output out_assign,
  output reg out_always_comb,
  output reg out_always_ff
);

  // XOR using assign statement (combinational logic)
  assign out_assign = a ^ b;

  // XOR using combinational always block (combinational logic)
  always @(*) begin
    out_always_comb = a ^ b;
  end

  // XOR using clocked always block (sequential logic with flip-flop)
  always @(posedge clk) begin
    out_always_ff <= a ^ b;
  end

endmodule
```

### Explanation:

- **`assign out_assign = a ^ b;`**: This line uses the `assign` statement to create a continuous assignment for the XOR operation. It is purely combinational and updates immediately when inputs change.

- **`always @(*) begin ... end`**: The `@(*)` sensitivity list indicates that this block should be evaluated whenever any of its input signals (`a`, `b`) change. This is another way to describe combinational logic, similar to the `assign` statement.

- **`always @(posedge clk) begin ... end`**: This block triggers on the positive edge of the clock signal (`clk`). The use of `<=` indicates non-blocking assignment, which is typical for sequential logic. This introduces a flip-flop, causing the output to be updated only at each clock cycle, thus introducing a delay.

This module provides three different implementations of an XOR gate, demonstrating both combinational and sequential logic in Verilog.