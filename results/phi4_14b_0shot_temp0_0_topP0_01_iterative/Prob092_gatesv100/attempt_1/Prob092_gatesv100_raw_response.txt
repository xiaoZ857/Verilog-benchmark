To implement the Verilog module `TopModule` based on the given description, we need to compute three different outputs (`out_both`, `out_any`, and `out_different`) from a 100-bit input vector `in`. Here's how each output is calculated:

1. **`out_both`:** This output indicates whether both the current bit and its left neighbor are '1'. Since there is no left neighbor for `in[99]`, we don't need to compute `out_both[99]`.

2. **`out_any`:** This output indicates if either the current bit or its right neighbor is '1'. There's no right neighbor for `in[0]`, so we don't need to compute `out_any[0]`.

3. **`out_different`:** This output checks if the current bit is different from its left neighbor, treating the vector as circular (i.e., `in[99]`'s left neighbor is `in[0]`).

Here's the Verilog implementation:

```verilog
module TopModule (
  input [99:0] in,
  output reg [98:0] out_both,
  output reg [99:1] out_any,
  output reg [99:0] out_different
);

  integer i;

  always @(*) begin
    // Calculate out_both
    for (i = 0; i < 99; i = i + 1) begin
      out_both[i] = in[i] & in[i+1];
    end

    // Calculate out_any
    for (i = 1; i <= 99; i = i + 1) begin
      out_any[i] = in[i-1] | in[i];
    end

    // Calculate out_different with wrap-around
    for (i = 0; i < 100; i = i + 1) begin
      if (i == 99) begin
        out_different[i] = in[i] ^ in[0]; // Wrap around: left neighbor of in[99] is in[0]
      end else begin
        out_different[i] = in[i] ^ in[i+1];
      end
    end
  end

endmodule
```

### Explanation:

- **`out_both`:** We iterate from `i = 0` to `98`. For each index, we compute the logical AND of `in[i]` and its left neighbor `in[i+1]`.

- **`out_any`:** We iterate from `i = 1` to `99`. For each index, we compute the logical OR of `in[i-1]` (right neighbor) and `in[i]`.

- **`out_different`:** We iterate over all indices from `0` to `99`. For each index, we compute the XOR between `in[i]` and its left neighbor. Special handling is done for `i = 99`, where the left neighbor is `in[0]` due to wrap-around.

This implementation ensures that all specified conditions are met efficiently using a single always block with combinational logic.