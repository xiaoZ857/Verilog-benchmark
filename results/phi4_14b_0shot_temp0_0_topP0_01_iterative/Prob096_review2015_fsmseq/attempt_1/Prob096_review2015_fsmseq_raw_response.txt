To implement a finite-state machine (FSM) in Verilog that searches for the sequence `1101` in an input bit stream, we need to define states that represent progress towards detecting this sequence. When the sequence is detected, the FSM should set `start_shifting` to 1 and maintain it until reset.

Here's a possible implementation:

```verilog
module TopModule (
    input clk,
    input reset,
    input data,
    output reg start_shifting
);

    // State encoding
    typedef enum logic [2:0] {
        IDLE = 3'b000,   // Initial state, waiting for sequence
        S1 = 3'b001,     // Detected '1'
        S11 = 3'b010,    // Detected '11'
        S110 = 3'b011,   // Detected '110'
        FOUND = 3'b100   // Sequence '1101' found
    } state_t;

    state_t current_state, next_state;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            start_shifting <= 0;
        end else begin
            current_state <= next_state;
            if (current_state == FOUND) begin
                start_shifting <= 1; // Maintain start_shifting as 1 once sequence is found
            end
        end
    end

    always_comb begin
        case (current_state)
            IDLE: begin
                if (data == 1'b1) begin
                    next_state = S1;
                end else begin
                    next_state = IDLE;
                end
            end

            S1: begin
                if (data == 1'b1) begin
                    next_state = S11;
                end else begin
                    next_state = IDLE; // Reset to IDLE on '0'
                end
            end

            S11: begin
                if (data == 1'b0) begin
                    next_state = S110;
                end else begin
                    next_state = S11; // Stay in S11 on another '1'
                end
            end

            S110: begin
                if (data == 1'b1) begin
                    next_state = FOUND;
                end else begin
                    next_state = IDLE; // Reset to IDLE on '0'
                end
            end

            FOUND: begin
                next_state = FOUND; // Remain in FOUND state until reset
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

endmodule
```

### Explanation:

1. **State Encoding**: We define a type `state_t` with states representing each step towards detecting the sequence `1101`. The states are:
   - `IDLE`: Waiting for the first '1'.
   - `S1`: Detected the first '1'.
   - `S11`: Detected '11'.
   - `S110`: Detected '110'.
   - `FOUND`: Sequence `1101` detected.

2. **State Transition Logic**: The FSM transitions between states based on the current state and input data:
   - From `IDLE`, it moves to `S1` if a '1' is detected.
   - From `S1`, it moves to `S11` if another '1' is detected, otherwise back to `IDLE`.
   - From `S11`, it moves to `S110` on detecting '0', or stays in `S11` for another '1'.
   - From `S110`, it transitions to `FOUND` on detecting '1', or goes back to `IDLE` on '0'.

3. **Output Logic**: Once the sequence is found (`FOUND` state), `start_shifting` is set to 1 and remains so until a reset occurs.

4. **Reset Handling**: The FSM resets to `IDLE`, and `start_shifting` is cleared when an active high synchronous reset is detected.

This implementation ensures that once the sequence `1101` is found, `start_shifting` remains asserted until the system is reset.