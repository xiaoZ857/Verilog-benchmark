To implement a 256-to-1 multiplexer with a single 256-bit wide input vector and an 8-bit selector, you can use Verilog to define the logic. The `sel` signal will determine which one of the 256 bits from the `in` vector is passed through to the output `out`.

Here's how you can implement this in Verilog:

```verilog
module TopModule (
  input [255:0] in,
  input [7:0] sel,
  output reg out
);

always @(*) begin
  // Use a single always block with blocking assignment for combinational logic.
  // Select the bit corresponding to `sel` from the `in` vector and assign it to `out`.
  out = in[sel];
end

endmodule
```

### Explanation:

- **Inputs and Outputs**: The module has a 256-bit input vector `in`, an 8-bit selector `sel`, and a single bit output `out`.
  
- **Combinational Logic**: Since the multiplexer is purely combinational, we use an `always @(*)` block. This ensures that any change in the inputs triggers recomputation of the outputs.

- **Indexing**: The expression `in[sel]` uses the 8-bit selector to index into the 256-bit input vector. When `sel = n`, it selects the nth bit from `in`.

This setup efficiently implements a 256-to-1 multiplexer using Verilog's indexing capabilities on vectors, which provides a simple and elegant solution.