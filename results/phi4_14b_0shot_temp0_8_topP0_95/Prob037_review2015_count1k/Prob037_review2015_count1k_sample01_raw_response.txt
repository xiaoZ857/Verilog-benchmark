To implement the described Verilog module, we need a counter that counts from 0 to 999 in binary. We will use a 10-bit register `q` because \(2^{10} = 1024\) is enough to represent numbers up to 999. The counter should reset to 0 when the synchronous active-high `reset` signal is asserted, and increment on each clock cycle until it reaches 999, after which it wraps around to 0.

Here's how you can implement this in Verilog:

```verilog
module TopModule (
    input clk,
    input reset,
    output reg [9:0] q
);

always @(posedge clk or posedge reset) begin
    if (reset) begin
        // Reset the counter to 0 on a high reset signal
        q <= 10'b0000000000;
    end else begin
        // Increment the counter unless it reaches 999, then wrap around to 0
        if (q == 10'd999) begin
            q <= 10'b0000000000;
        end else begin
            q <= q + 1;
        end
    end
end

endmodule
```

### Explanation:
- **Module Declaration**: The module `TopModule` is declared with an input clock signal `clk`, a synchronous reset signal `reset`, and a 10-bit output `q`.
  
- **Synchronous Process**: 
  - The always block is triggered on the positive edge of either `clk` or `reset`. This ensures that any changes occur synchronously with the clock cycle.
  
- **Reset Handling**:
  - If `reset` is high, we set `q` to `10'b0000000000`, which represents binary for decimal 0.

- **Counter Logic**:
  - When not in reset (`else` block), if `q` reaches `999` (binary `1111100111`), the counter wraps around by resetting `q` back to `0`.
  - For other values of `q`, it increments by 1 on each clock cycle.

This implementation ensures that the counter functions as specified, counting from 0 to 999 and wrapping back to 0 after reaching 999.