To implement a Verilog module with 16 D flip-flops, each flip-flop representing one bit of the register, and controlled by byte-enable signals and a synchronous reset, you can create a module as described below. The module will use two bytes, where `byteena[1]` controls the upper byte (bits 15:8) and `byteena[0]` controls the lower byte (bits 7:0). Here is how you could structure this in Verilog:

```verilog
module TopModule (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output reg [15:0] q
);

    // Declare the internal registers
    always @(posedge clk or negedge resetn) begin
        if (!resetn) begin
            // Synchronous active-low reset, set all bits to 0
            q <= 16'b0000000000000000;
        end else begin
            // Check byteena and update the appropriate bytes in q
            if (byteena[1]) begin
                q[15:8] <= d[15:8]; // Update upper byte if enabled
            end
            if (byteena[0]) begin
                q[7:0]  <= d[7:0];  // Update lower byte if enabled
            end
        end
    end

endmodule
```

### Explanation:

1. **Module Declaration:** 
   - The `TopModule` has inputs for the clock (`clk`), reset (`resetn`), byte enable signals (`byteena[1:0]`), and data input (`d[15:0]`). The output is the 16-bit register `q`.

2. **Synchronous Reset Handling:** 
   - The flip-flops are updated on every positive edge of `clk`. If `resetn` is low, it triggers a synchronous reset by setting all bits of `q` to zero.

3. **Byte Enable Logic:**
   - The byte-enable signals determine whether the upper or lower bytes should be updated.
   - If `byteena[1]` is set (high), the upper byte (`d[15:8]`) is written into `q[15:8]`.
   - Similarly, if `byteena[0]` is set, the lower byte (`d[7:0]`) is written into `q[7:0]`.

This design ensures that only specified parts of the register are updated based on the input control signals, maintaining efficient and controlled data handling.