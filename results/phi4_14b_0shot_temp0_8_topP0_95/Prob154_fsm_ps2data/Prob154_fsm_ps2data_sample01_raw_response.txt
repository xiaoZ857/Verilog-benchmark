To implement the described finite state machine (FSM) with a datapath module for detecting and extracting messages from an input byte stream, we can design it using Verilog. The FSM will operate based on the given criteria to detect the start of a message when `in[3]` is set to 1 and capture three consecutive bytes as a complete message.

Here's how you can implement this in Verilog:

```verilog
module TopModule (
    input wire clk,
    input wire [7:0] in,
    input wire reset,
    output reg [23:0] out_bytes,
    output reg done
);

    // State encoding
    typedef enum logic [1:0] {
        IDLE = 2'b00,  // Waiting for start byte
        RECV_BYTE_1 = 2'b01,  // Receiving first byte of message
        RECV_BYTE_2 = 2'b10,  // Receiving second byte of message
        RECV_BYTE_3 = 2'b11   // Receiving third byte of message
    } state_t;

    state_t current_state, next_state;
    
    reg [7:0] byte1, byte2;  // Registers to store the first two bytes

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            done <= 0;
            out_bytes <= 24'b0;
        end else begin
            current_state <= next_state;

            case (current_state)
                RECV_BYTE_1: begin
                    byte1 <= in;
                end
                RECV_BYTE_2: begin
                    byte2 <= in;
                end
                RECV_BYTE_3: begin
                    out_bytes <= {byte1, byte2, in};
                    done <= 1;
                end
            endcase

            // Reset the 'done' signal only after the output has been latched
            if (current_state == RECV_BYTE_3) begin
                done <= 0;
            end
        end
    end

    always_comb begin
        next_state = current_state;  // Default to stay in same state
        case (current_state)
            IDLE: begin
                if (in[3]) begin
                    next_state = RECV_BYTE_1;
                end
            end
            RECV_BYTE_1: begin
                next_state = RECV_BYTE_2;
            end
            RECV_BYTE_2: begin
                next_state = RECV_BYTE_3;
            end
            RECV_BYTE_3: begin
                next_state = IDLE;  // Return to idle after receiving a message
            end
        endcase
    end

endmodule
```

### Explanation:

1. **State Encoding:** We define states `IDLE`, `RECV_BYTE_1`, `RECV_BYTE_2`, and `RECV_BYTE_3`. The FSM starts in the `IDLE` state, transitioning to `RECV_BYTE_1` when it detects a byte with its 4th bit (`in[3]`) as 1.

2. **State Transitions:** 
   - In the `IDLE` state, we wait for a byte where `in[3] == 1` and then move to `RECV_BYTE_1`.
   - After receiving the first byte in `RECV_BYTE_1`, transition to `RECV_BYTE_2`.
   - After receiving the second byte in `RECV_BYTE_2`, transition to `RECV_BYTE_3`.
   - In `RECV_BYTE_3`, store all three bytes and set `done` high. Then return to `IDLE`.

3. **Outputs:**
   - The message (`out_bytes`) is assembled using concatenation of the stored bytes once `done` goes high.
   - The `done` signal remains high for one clock cycle after the third byte is received, indicating that a complete message has been captured.

4. **Reset Logic:** A synchronous reset sets the FSM back to its initial state (`IDLE`) and clears outputs when asserted. 

This design ensures messages are correctly identified according to the specified conditions and transmitted through `out_bytes` with an appropriate `done` signal.