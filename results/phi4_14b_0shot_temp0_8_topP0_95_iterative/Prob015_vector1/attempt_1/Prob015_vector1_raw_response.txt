To implement the Verilog module based on your description, we need to split a 16-bit input half-word into its lower and upper bytes. The lower byte is comprised of bits `[7:0]` and the upper byte from bits `[15:8]`. We can achieve this using simple bit slicing in Verilog.

Here's how you can define the `TopModule`:

```verilog
module TopModule (
  input [15:0] in,
  output [7:0] out_hi,
  output [7:0] out_lo
);

  // Assign the upper byte to out_hi
  assign out_hi = in[15:8];

  // Assign the lower byte to out_lo
  assign out_lo = in[7:0];

endmodule
```

### Explanation:
- **`input [15:0] in;`**: This defines a 16-bit input port named `in`.
- **`output [7:0] out_hi;`**: This is an 8-bit output for the upper byte.
- **`output [7:0] out_lo;`**: This is an 8-bit output for the lower byte.

- **`assign out_hi = in[15:8];`**: We use bit slicing to extract bits `[15:8]` from `in` and assign them to `out_hi`. This gives us the upper byte of the input.
  
- **`assign out_lo = in[7:0];`**: Similarly, we slice bits `[7:0]` from `in` and assign them to `out_lo`, which provides us with the lower byte.

This module is purely combinational, meaning it reacts immediately to changes in its inputs without any need for clock signals or storage elements. The outputs will always reflect the current state of the input half-word's bytes.