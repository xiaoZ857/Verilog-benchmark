To implement a full adder in Verilog, you need to create a module that takes three inputs: two single-bit numbers `a` and `b`, and an additional carry-in bit `cin`. The module should produce two outputs: the `sum` of these three bits and the `carry-out` (`cout`). 

A full adder can be represented by the following equations:

- \( \text{sum} = a \oplus b \oplus \text{cin} \)
- \( \text{cout} = (a \cdot b) + (\text{cin} \cdot (a \oplus b)) \)

Here's how you can implement this in Verilog:

```verilog
module FullAdder (
  input a,
  input b,
  input cin,
  output reg cout,
  output reg sum
);

  always @(*) begin
    // Calculate the sum using XOR gates
    sum = a ^ b ^ cin;
    
    // Calculate the carry-out using AND and OR operations
    cout = (a & b) | ((cin) & (a ^ b));
  end

endmodule

// Top-level module to test the FullAdder
module TopModule (
  input wire a,
  input wire b,
  input wire cin,
  output wire cout,
  output wire sum
);

  // Instantiate the FullAdder
  FullAdder adder (
    .a(a),
    .b(b),
    .cin(cin),
    .cout(cout),
    .sum(sum)
  );

endmodule
```

### Explanation:

- **Sum Calculation**: The `sum` is computed using XOR operations. This effectively performs the addition of three bits.
  
- **Carry-out Calculation**: 
  - The first part `(a & b)` calculates if both inputs have a carry.
  - The second part `(cin & (a ^ b))` checks if there's a carry when considering `cin` and the sum of `a` and `b`.
  - These two parts are combined using an OR operation to get the final `cout`.

- **Always Block**: The `always @(*)` block is used for combinational logic, ensuring that changes in inputs automatically trigger recomputation of outputs.

- **TopModule**: This module instantiates the `FullAdder`, connecting its ports to the top-level input and output signals.