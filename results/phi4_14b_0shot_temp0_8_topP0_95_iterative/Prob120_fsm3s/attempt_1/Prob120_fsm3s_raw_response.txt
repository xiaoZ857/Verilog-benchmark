To implement the described Moore state machine using Verilog, we need to define a module that holds the current state and transitions between states based on inputs. The Moore FSM has one input (`in`), one output (`out`), four states (A, B, C, D), and an active high synchronous reset.

Here's how you can implement this state machine in Verilog:

```verilog
module TopModule (
  input wire clk,
  input wire in,
  input wire reset,
  output reg out
);

  // State encoding
  typedef enum logic [1:0] {
    A = 2'b00,  // State A
    B = 2'b01,  // State B
    C = 2'b10,  // State C
    D = 2'b11   // State D
  } state_t;

  // Registers to hold the current and next states
  reg [1:0] current_state;
  reg [1:0] next_state;

  // Combinational logic for next state calculation
  always @(*) begin
    case (current_state)
      A: next_state = in ? B : A; // From A, go to B if in=1 else stay at A
      B: next_state = in ? B : C; // From B, go to B if in=1 else go to C
      C: next_state = in ? D : A; // From C, go to D if in=1 else go to A
      D: next_state = in ? B : C; // From D, go to B if in=1 else go to C
      default: next_state = A;
    endcase
  end

  // Sequential logic for state transition and output generation
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      current_state <= A; // Reset to state A
    end else begin
      current_state <= next_state; // Transition to the next state
    end
  end

  // Output logic based on the Moore output function
  always @(*) begin
    case (current_state)
      A: out = 0;
      B: out = 0;
      C: out = 0;
      D: out = 1;
      default: out = 0; // Default case to handle unexpected states
    endcase
  end

endmodule
```

### Explanation:

- **State Encoding**: We use a 2-bit binary encoding for the four states (A, B, C, D).
  
- **Registers**:
  - `current_state`: Holds the current state of the FSM.
  - `next_state`: Holds the next state to transition into.

- **Next State Logic**: A combinational logic block determines the `next_state` based on the `current_state` and input (`in`). The transitions are implemented using a case statement.

- **Sequential Logic**:
  - On every positive edge of `clk`, if `reset` is high, the FSM resets to state A.
  - Otherwise, it updates the `current_state` to `next_state`.

- **Output Logic**: Based on the Moore machine definition, the output `out` is determined solely by the current state.

This implementation ensures that the FSM behaves as per the given state transition table with an active high synchronous reset functionality.