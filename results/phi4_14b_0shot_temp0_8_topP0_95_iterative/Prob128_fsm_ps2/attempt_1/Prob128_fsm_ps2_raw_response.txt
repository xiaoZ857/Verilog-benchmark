To implement the Verilog module described, we need to create a finite state machine (FSM) that processes incoming bytes from a PS/2 mouse and identifies complete three-byte messages. The FSM will use the condition `in[3] = 1` as an indicator of the start of a new message.

Here's how you can implement this in Verilog:

```verilog
module TopModule (
    input wire clk,
    input wire [7:0] in,
    input wire reset,
    output reg done
);

    // Define states for the FSM
    typedef enum logic [1:0] {
        IDLE,      // Waiting for a new message start byte
        RECEIVE_2, // Received first byte; waiting for second byte
        RECEIVE_3  // Received second byte; waiting for third byte
    } state_t;

    state_t current_state, next_state;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            done <= 1'b0;
        end else begin
            current_state <= next_state;
            
            // Signal 'done' when transitioning from RECEIVE_3 to IDLE
            if (current_state == RECEIVE_3 && next_state == IDLE) begin
                done <= 1'b1;
            end else begin
                done <= 1'b0;
            end
        end
    end

    always_comb begin
        // Default assignments for next state and outputs
        next_state = current_state;
        
        case (current_state)
            IDLE: begin
                if (in[3] == 1) begin
                    next_state = RECEIVE_2; // Found a start byte
                end else begin
                    next_state = IDLE;
                end
            end
            
            RECEIVE_2: begin
                next_state = RECEIVE_3; // Move to the third byte after second is received
            end

            RECEIVE_3: begin
                next_state = IDLE; // Reset to IDLE after receiving a full message
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

endmodule
```

### Explanation:
- **State Definitions**: We define three states for the FSM: `IDLE`, `RECEIVE_2`, and `RECEIVE_3`.
  - `IDLE`: Waiting to detect a message start byte.
  - `RECEIVE_2`: The first byte of a message has been received, waiting for the second byte.
  - `RECEIVE_3`: The second byte has been received; now waiting for the third byte.

- **State Transitions**:
  - From `IDLE`, transition to `RECEIVE_2` when `in[3] == 1`.
  - From `RECEIVE_2`, always move to `RECEIVE_3` because we assume that once a start byte is detected, the next two bytes are part of the message.
  - From `RECEIVE_3`, transition back to `IDLE` after receiving all three bytes.

- **Output Logic**:
  - The `done` signal is asserted in the cycle immediately following the reception of the third byte. This is achieved by checking if we're transitioning from `RECEIVE_3` to `IDLE`.

- **Reset Handling**: 
  - On reset, the FSM is set back to the `IDLE` state and clears the `done` signal.

This implementation ensures that a three-byte message is correctly identified and signaled with `done`.