To implement the Moore state machine described, we need to derive the logic equations for both the next-state and output based on the given one-hot encoding. Let's break down the task:

### One-Hot Encoding

The states are encoded as follows:
- S = 10'b0000000001
- S1 = 10'b0000000010
- S11 = 10'b0000000100
- S110 = 10'b0000001000
- B0 = 10'b0000010000
- B1 = 10'b0000100000
- B2 = 10'b0001000000
- B3 = 10'b0010000000
- Count = 10'b0100000000
- Wait = 10'b1000000000

### Next-State Logic

Let's derive the next-state logic:

1. **B3_next**: Asserted when transitioning to state B3 from S110 and d=1.
   \[
   B3\_next = (state[7] \land d)
   \]

2. **S_next**: Asserted when transitioning to state S from S, S1, S11, S110, or Wait.
   - From S: Always true if d=0.
   - From S1: If d=0.
   - From S11: If d=0.
   - From S110: Always true.
   - From Wait: If ack=1.

   \[
   S\_next = (state[0] \land \neg d) \lor (state[1] \land \neg d) \lor (state[2] \land \neg d) \lor state[3] \lor (state[9] \land ack)
   \]

3. **S1_next**: Asserted when transitioning to state S1 from S and d=1.
   \[
   S1\_next = (state[0] \land d)
   \]

4. **Count_next**: Asserted when transitioning to state Count from B3.
   \[
   Count\_next = state[7]
   \]

5. **Wait_next**: Asserted when transitioning to state Wait from Count and done_counting=1.
   \[
   Wait\_next = (state[8] \land done\_counting)
   \]

### Output Logic

Now, let's derive the output logic:

1. **done**: Asserted in state Wait.
   \[
   done = state[9]
   \]

2. **counting**: Asserted in state Count.
   \[
   counting = state[8]
   \]

3. **shift_ena**: Asserted in states B0, B1, B2, and B3.
   \[
   shift\_ena = state[4] \lor state[5] \lor state[6] \lor state[7]
   \]

### Verilog Implementation

Here's the Verilog code for the combinational logic:

```verilog
module TopModule (
  input d,
  input done_counting,
  input ack,
  input [9:0] state, // 10-bit one-hot current state
  output B3_next,
  output S_next,
  output S1_next,
  output Count_next,
  output Wait_next,
  output done,
  output counting,
  output shift_ena
);

  assign B3_next = (state[7] & d);
  assign S_next = ((state[0] & ~d) | (state[1] & ~d) | (state[2] & ~d) | state[3] | (state[9] & ack));
  assign S1_next = (state[0] & d);
  assign Count_next = state[7];
  assign Wait_next = (state[8] & done_counting);

  assign done = state[9];
  assign counting = state[8];
  assign shift_ena = state[4] | state[5] | state[6] | state[7];

endmodule
```

This code correctly implements the next-state and output logic for the given Moore machine using one-hot encoding.